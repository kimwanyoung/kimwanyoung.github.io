{"/pages/cs/": {
    "title": "CS",
    "keywords": "CS",
    "url": "/pages/cs/",
    "body": "아직 작성된 글이 없습니다."
  },"/pages/network/": {
    "title": "네트워크",
    "keywords": "Network",
    "url": "/pages/network/",
    "body": "아직 작성된 글이 없습니다."
  },"/pages/spring/": {
    "title": "Spring",
    "keywords": "Spring",
    "url": "/pages/spring/",
    "body": "아직 작성된 글이 없습니다."
  },"/pages/sql/": {
    "title": "SQL",
    "keywords": "SQL",
    "url": "/pages/sql/",
    "body": "COUNT(*) vs COUNT(column_name) 완벽 이해하기 - 2025.10.06"
  },"/sql/2025-10-06-count-star-vs-count-column.html": {
    "title": "COUNT(*) vs COUNT(column_name) 완벽 이해하기",
    "keywords": "SQL",
    "url": "/sql/2025-10-06-count-star-vs-count-column.html",
    "body": "SQL에서 데이터 개수를 세는 COUNT 함수는 매우 자주 사용되지만, COUNT(*)와 COUNT(column_name)의 차이를 정확히 이해하지 못하면 예상치 못한 결과를 마주할 수 있습니다. 이 글에서는 두 방식의 차이점과 내부 동작 원리, 성능까지 깊이 있게 다뤄보겠습니다. 기본 개념 COUNT(*) 모든 행의 개수를 반환합니다. NULL 값을 포함한 모든 행을 카운트합니다. 어떤 컬럼 값도 확인하지 않고, 단순히 행의 존재 여부만 확인합니다. COUNT(column_name) 특정 컬럼에서 NULL이 아닌 값의 개수를 반환합니다. NULL 값은 카운트에서 제외됩니다. 해당 컬럼의 값을 실제로 확인해야 합니다. 실전 예제 다음과 같은 users 테이블이 있다고 가정해봅시다: id name email phone 1 Alice alice@example.com NULL 2 Bob bob@example.com 010-1234-5678 3 Charlie NULL 010-9876-5432 4 David david@example.com NULL 쿼리 비교 -- 전체 행 개수 SELECT COUNT(*) FROM users; -- 결과: 4 -- email 값이 있는 행 개수 SELECT COUNT(email) FROM users; -- 결과: 3 (Charlie의 email이 NULL이므로 제외) -- phone 값이 있는 행 개수 SELECT COUNT(phone) FROM users; -- 결과: 2 (Alice와 David의 phone이 NULL이므로 제외) -- NULL이 아닌 모든 컬럼 조합 개수 SELECT COUNT(DISTINCT email) FROM users; -- 결과: 3 (중복 제거 + NULL 제외) 내부 동작 원리 COUNT(*) 동작 방식 SELECT COUNT(*) FROM orders WHERE status = 'completed'; 인덱스 스캔 최적화: 대부분의 DBMS는 가장 작은 인덱스를 사용하여 행 개수를 셉니다. 데이터 페이지 접근 최소화: 실제 테이블 데이터에 접근하지 않고, 인덱스만으로 카운트 가능합니다. NULL 체크 불필요: 행의 존재만 확인하면 되므로 컬럼 값 검사를 생략합니다. COUNT(column_name) 동작 방식 SELECT COUNT(email) FROM orders WHERE status = 'completed'; 컬럼 값 접근 필수: 해당 컬럼이 NULL인지 확인해야 합니다. 인덱스 활용 조건: email 컬럼에 인덱스가 있어야 효율적입니다. 데이터 읽기 오버헤드: NULL 체크를 위해 실제 컬럼 값을 읽어야 합니다. 성능 차이 분석 InnoDB (MySQL) 기준 -- 1. COUNT(*) - 가장 빠름 SELECT COUNT(*) FROM large_table; -- Secondary Index 사용, 데이터 페이지 접근 X -- 2. COUNT(primary_key) - 빠름 SELECT COUNT(id) FROM large_table; -- Primary Key는 NOT NULL 보장, 인덱스 사용 -- 3. COUNT(nullable_column) - 느림 SELECT COUNT(email) FROM large_table; -- NULL 체크 필요, 컬럼 값 읽기 필요 실제 성능 테스트 (1,000만 건 기준) 쿼리 실행 시간 인덱스 사용 비고 COUNT(*) 0.5초 Secondary Index 최적화 COUNT(id) 0.6초 Primary Key NULL 체크 X COUNT(email) 2.3초 email 인덱스 NULL 체크 O COUNT(no_index_col) 15초 Full Table Scan 인덱스 없음 심화 내용 1. WHERE 절과의 상호작용 -- 케이스 1: 인덱스 활용 가능 SELECT COUNT(*) FROM orders WHERE created_at &gt; '2025-01-01'; -- created_at에 인덱스 있으면 Index Range Scan -- 케이스 2: 커버링 인덱스 활용 CREATE INDEX idx_status_created ON orders(status, created_at); SELECT COUNT(*) FROM orders WHERE status = 'pending' AND created_at &gt; '2025-01-01'; -- Index Only Scan 가능 2. COUNT(DISTINCT column_name) -- 중복 제거 카운트 SELECT COUNT(DISTINCT user_id) FROM orders; -- 내부적으로 임시 테이블 또는 해시 테이블 사용 -- 메모리 사용량 증가, 정렬 발생 가능 최적화 팁: -- 대용량 데이터의 경우 GROUP BY 활용 SELECT COUNT(*) FROM ( SELECT user_id FROM orders GROUP BY user_id ) AS distinct_users; 3. NULL 처리 전략 -- NULL을 0으로 카운트하고 싶은 경우 SELECT COUNT(*) FROM users WHERE email IS NOT NULL; -- NULL 포함 여부 확인 SELECT COUNT(*) AS total_rows, COUNT(email) AS email_not_null, COUNT(*) - COUNT(email) AS email_null FROM users; 4. 파티셔닝 테이블에서의 COUNT -- 파티션 프루닝 활용 SELECT COUNT(*) FROM sales_2025 WHERE sale_date BETWEEN '2025-01-01' AND '2025-01-31'; -- 해당 파티션만 스캔 -- 전체 파티션 카운트 SELECT COUNT(*) FROM sales_partitioned; -- 모든 파티션 통계 합산 (메타데이터 활용 가능) DBMS별 최적화 차이 MySQL/MariaDB InnoDB는 COUNT(*)를 실시간 계산합니다 (통계 정보 미사용). MyISAM은 테이블 메타데이터에 행 개수 저장 (WHERE 없을 때 즉시 반환). -- InnoDB 최적화 EXPLAIN SELECT COUNT(*) FROM innodb_table; -- Using index (Secondary Index 사용) PostgreSQL MVCC 특성상 COUNT(*)도 전체 스캔 필요할 수 있음. pg_stat_user_tables의 통계 활용 가능 (근사치). -- 근사치 빠른 조회 SELECT reltuples::bigint AS estimate FROM pg_class WHERE relname = 'table_name'; Oracle COUNT(*)와 COUNT(1) 동일 (옵티마이저가 같게 처리). 병렬 쿼리 자동 활용 (대용량 테이블). 실무 Best Practices 1. 일반적인 행 개수 조회 -- 권장: COUNT(*) SELECT COUNT(*) FROM orders; 2. NOT NULL 컬럼 카운트 -- COUNT(*)와 동일한 결과지만 의도 명확화 SELECT COUNT(id) FROM orders; -- id가 PRIMARY KEY인 경우 3. NULL 가능 컬럼 유효 값 개수 -- 명확한 의도 표현 SELECT COUNT(email) FROM users; -- email이 있는 사용자 수 4. 조건부 카운트 -- CASE 활용 SELECT COUNT(*) AS total, COUNT(CASE WHEN status = 'active' THEN 1 END) AS active_count, COUNT(CASE WHEN email IS NOT NULL THEN 1 END) AS email_count FROM users; 5. 대용량 테이블 최적화 -- 샘플링 기법 SELECT COUNT(*) * 100 AS estimated_total FROM large_table TABLESAMPLE SYSTEM (1); -- 1% 샘플링 정리 항목 COUNT(*) COUNT(column_name) 카운트 대상 모든 행 NULL이 아닌 값만 NULL 처리 포함 제외 성능 빠름 (인덱스 최적화) 상대적으로 느림 사용 목적 전체 행 개수 유효 데이터 개수 인덱스 필요성 옵션 (최적화용) 권장 (필수 수준) 핵심 원칙: 전체 행 개수가 필요하면 COUNT(*) 사용 특정 컬럼의 유효 값 개수가 필요하면 COUNT(column_name) 사용 성능이 중요하면 적절한 인덱스 구성 필수 대용량 데이터는 통계 정보나 샘플링 활용 검토 참고 자료 MySQL Documentation: Optimizing COUNT() Queries PostgreSQL Wiki: Count Estimation Oracle Performance Tuning Guide"
  }}
